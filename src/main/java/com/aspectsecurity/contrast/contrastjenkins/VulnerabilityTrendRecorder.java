package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.exceptions.UnauthorizedException;
import com.contrastsecurity.http.FilterForm;
import com.contrastsecurity.http.ServerFilterForm;
import com.contrastsecurity.http.UrlBuilder;
import com.contrastsecurity.models.*;
import com.contrastsecurity.sdk.ContrastSDK;
import hudson.AbortException;
import hudson.Extension;
import hudson.Launcher;
import hudson.model.AbstractBuild;
import hudson.model.AbstractProject;
import hudson.model.Action;
import hudson.model.BuildListener;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.BuildStepMonitor;
import hudson.tasks.Publisher;
import hudson.tasks.Recorder;
import hudson.util.ListBoxModel;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.StaplerRequest;

import java.io.IOException;
import java.util.*;


/**
 * Vulnerability Trend Builder
 * <p>
 * Checks the number of vulnerabilities in the application against the configured threshold.
 */
public class VulnerabilityTrendRecorder extends Recorder {
    private List<ThresholdCondition> conditions;
    private String teamServerProfileName;

    @DataBoundConstructor
    public VulnerabilityTrendRecorder(List<ThresholdCondition> conditions, String teamServerProfileName) {
        this.conditions = conditions;
        this.teamServerProfileName = teamServerProfileName;
    }

    public List<ThresholdCondition> getConditions() {
        return conditions;
    }

    public TeamServerProfile getProfile() {
        return getProfile(teamServerProfileName);
    }

    public String getTeamServerProfileName() {
        return teamServerProfileName;
    }

    private static TeamServerProfile getProfile(String profileName) {
        final TeamServerProfile[] profiles = new ContrastPluginConfig.ContrastPluginConfigDescriptor().getTeamServerProfiles();

        if (profileName == null && profiles.length > 0)
            return profiles[0];

        for (TeamServerProfile profile : profiles) {
            if (profile.getName().equals(profileName))
                return profile;
        }
        return null;
    }

    @Override
    public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, final BuildListener listener) throws InterruptedException, IOException {
        logMessage(listener, "Checking the number of vulnerabilities for this application.");
        ContrastSDK contrastSDK;
        Traces traces;
        Set<Trace> resultTraces = new HashSet<>();

        TeamServerProfile profile = getProfile();

        if (profile.getApplicationName() == null) {
            throw new AbortException("An application name must be configured to check for vulnerabilities.");
        }

        if (profile.getOrgUuid() == null) {
            throw new AbortException("An organization id must be configured to check for vulnerabilities.");
        }

        if (profile.getServerName() == null) {
            throw new AbortException("A server name must be configured to check for vulnerabilities.");
        }

        contrastSDK = new ContrastSDK(profile.getUsername(), profile.getServiceKey(), profile.getApiKey(), profile.getTeamServerUrl());

        String applicationId = getApplicationId(contrastSDK, profile.getOrgUuid(), profile.getApplicationName());
        long serverId = getServerId(contrastSDK, profile.getOrgUuid(), profile.getServerName(), applicationId);

        // iterate over conditions; fail on first
        for (ThresholdCondition condition : conditions) {
            logMessage(listener, "Checking the threshold condition where " + condition.toString());

            int vulnTypeCount = 0; // used for vuln type

            try {
                FilterForm filterForm = new FilterForm();

                if (condition.getThresholdSeverity() != null) {
                    filterForm.setSeverities(UrlBuilder.getSeverityList(condition.getThresholdSeverity()));
                } else {
                    filterForm = null;
                }

                if (condition.getThresholdVulnType() == null) {
                    traces = contrastSDK.getTracesWithFilter(profile.getOrgUuid(), applicationId, "servers", Long.toString(serverId), filterForm);
                } else {
                    traces = contrastSDK.getTraceFilterByRule(profile.getOrgUuid(), applicationId, condition.getThresholdVulnType(), filterForm);

                    for (Trace trace: traces.getTraces()) {
                        if (trace.getRule().equals(condition.getThresholdVulnType())) {
                            vulnTypeCount += 1;
                        }
                    }
                }
            } catch (Exception e) {
                logMessage(listener, e.getMessage());
                throw new AbortException("Unable to connect to TeamServer.");
            }

            resultTraces.addAll(traces.getTraces());

            int thresholdCount = Integer.parseInt(condition.getThresholdCount());

            if ((condition.getThresholdVulnType() != null && vulnTypeCount > thresholdCount) || traces.getCount() > thresholdCount) {
                buildResult(resultTraces, build);

                throw new AbortException("Failed on the threshold condition where " + condition.toString());
            }
        }

        buildResult(resultTraces, build);

        logMessage(listener, "This build passes all vulnerability threshold conditions!");

        return true;
    }

    /**
     * Helper method for logging messages.
     *
     * @param listener Listener
     * @param msg      String to log
     */
    private void logMessage(BuildListener listener, String msg) {
        listener.getLogger().println("[Contrast - VulnerabilityTrendRecorder] - " + msg);
    }

    /** Retrieves the application id by application name; else null
     *
     * @param sdk Contrast SDK object
     * @param applicationName application name to filter on
     * @return String of the application
     * @throws AbortException
     */
    private String getApplicationId(ContrastSDK sdk, String organizationUuid, String applicationName) throws AbortException {

        Applications applications;

        try {
            applications = sdk.getApplications(organizationUuid);
        } catch (IOException e) {
            throw new AbortException("Unable to retrieve the applications.");
        } catch (UnauthorizedException e) {
            throw new AbortException("Unable to connect to TeamServer.");
        }

        for(Application application: applications.getApplications()) {
            if (applicationName.equals(application.getName())) {
                return application.getId();
            }
        }

        throw new AbortException("Application with name '" + applicationName + "' not found.");
    }

    /** Retrieves the server id by server name
     *
     * @param sdk Contrast SDK object
     * @param organizationUuid uuid of the organization
     * @param serverName name of the server to filter on
     * @param applicationId application id to filter on
     * @return Long id of the server
     * @throws AbortException
     */
    private long getServerId(ContrastSDK sdk, String organizationUuid, String serverName, String applicationId) throws AbortException {
        ServerFilterForm serverFilterForm = new ServerFilterForm();
        serverFilterForm.setApplicationIds(Arrays.asList(applicationId));
        serverFilterForm.setQ(serverName);

        Servers servers;
        long serverId;

        try {
            servers = sdk.getServersWithFilter(organizationUuid, serverFilterForm);
        } catch (IOException e) {
            throw new AbortException("Unable to retrieve the servers.");
        } catch (UnauthorizedException e) {
            throw new AbortException("Unable to connect to TeamServer.");
        }

        if (!servers.getServers().isEmpty()) {
            serverId = servers.getServers().get(0).getServerId();
        } else {
            throw new AbortException("Server with name '" + serverName + "' not found.");
        }

        return serverId;
    }

    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }

    @Override
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.NONE;
    }

    @Override
    public Action getProjectAction(AbstractProject<?, ?> project) {
        return new VulnerabilityTrendProjectAction(project);
    }

    /**
     * Descriptor for {@link VulnerabilityTrendRecorder}.
     */
    @Extension
    public static class DescriptorImpl extends BuildStepDescriptor<Publisher> {

        private List<ThresholdCondition> conditions;

        public DescriptorImpl() {
            super(VulnerabilityTrendRecorder.class);
            load();
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillTeamServerProfileNameItems() {
            final ListBoxModel model = new ListBoxModel();

            for (TeamServerProfile profile : new ContrastPluginConfig.ContrastPluginConfigDescriptor().getTeamServerProfiles()) {
                model.add(profile.getName(), profile.getName());
            }

            return model;
        }

        /**
         * Allows this builder to be available for all classes.
         *
         * @param aClass Passed in class.
         * @return true
         */
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        /**
         * Display name in the Build Action dropdown.
         *
         * @return String
         */
        public String getDisplayName() {
            return "Verify Vulnerability Threshold";
        }

        /**
         * Save's the publisher's config.jelly data.
         *
         * @param req  StaplerRequest
         * @param json Json of the form for this Publisher
         * @return if the save was successful
         * @throws FormException invalid form
         */
        @Override
        public Publisher newInstance(StaplerRequest req, JSONObject json) throws FormException {
            final JSONArray array = json.optJSONArray("conditions");

            if (array != null) {
                conditions = req.bindJSONToList(ThresholdCondition.class, array);
            } else {
                if (json.keySet().isEmpty()) {
                    conditions = new ArrayList<>();
                } else {
                    conditions.clear();
                    conditions.add(req.bindJSON(ThresholdCondition.class, json.getJSONObject("conditions")));
                }
            }

            save();

            return new VulnerabilityTrendRecorder(conditions, (String) json.get("teamServerProfileName"));
        }

        public void setConditions(List<ThresholdCondition> conditions) {
            this.conditions = conditions;
        }
    }


    /**
     * Builds a String representation of the Traces found when checking for vulnerabilities.
     *
     * @param traces
     * @param build
     */
    private void buildResult(Set<Trace> traces, AbstractBuild<?, ?> build) {
        Map<String, Integer> traceResult = new HashMap<>();
        Map<String, Integer> severityResult = new HashMap<>();

        for (Trace trace : traces) {

            if (severityResult.containsKey(trace.getSeverity())) {
                Integer previousCount = severityResult.get(trace.getSeverity());
                severityResult.put(trace.getSeverity(), previousCount + 1);
            } else {
                severityResult.put(trace.getSeverity(), 1);
            }

            if (traceResult.containsKey(trace.getRule())) {
                Integer previousCount = traceResult.get(trace.getRule());
                traceResult.put(trace.getRule(), previousCount + 1);
            } else {
                traceResult.put(trace.getRule(), 1);
            }
        }

        // Add remaining severities for chart
        for (String severity : SEVERITIES) {
            if (!severityResult.containsKey(severity)) {
                severityResult.put(severity, 0);
            }
        }

        VulnerabilityTrendResult result = new VulnerabilityTrendResult(traceResult, severityResult);

        build.addAction(new VulnerabilityFrequencyAction(result, build));
    }

    private static final List<String> SEVERITIES = Arrays.asList("Note", "Low", "Medium", "High", "Critical");

}